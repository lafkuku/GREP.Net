<#+
// <copyright file="IContext.cs.ttinclude" company="CompDJ">
//  Copyright © CompDJ. All Rights Reserved.
// </copyright>

/// <summary>T4 Template file.</summary>
public class IContextCs : T4TemplateBase
{
    /// <summary>Initializes a new instance of the IContextCs class.</summary>
    public IContextCs()
    {
		this.OutputName = "IContext";
		this.OutputExtension = ".cs";
    }
	
	/// <summary>Renders output.</summary>
	public override string TransformText()
	{
		CodeGenerationTools code = new CodeGenerationTools(this);
		string currentNamespace = this.GetNamespace(T4Config.RepositoryNamespace, T4Config.Namespace);
		string usings = this.GetUsings(T4Config.RepositoryNamespace, T4Config.Namespace);
#>
// <copyright file="<#=this.OutputName#><#=T4Config.LanguageFileString()#>" company="<#=T4Config.CompanyName#>">
//  Copyright (c) <#=T4Config.CompanyName#>. All Rights Reserved.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#=currentNamespace#>
{
	using System;
    using System.Data.Objects;
<#=usings#>
    /// <summary>Interface for the context to enable unit testing and fake context</summary>
    [System.CodeDom.Compiler.GeneratedCode("<#=T4Config.AppName#>", "<#=T4Config.AppVersion#>")]
	public interface IContext : IDisposable
    {
<#+
	foreach (EntityType table in T4Gen.Parser.Metadata.GetItems<EntityType>().OrderBy(c => c.Name))
		{
#>
        /// <summary>Gets the <#=code.Escape(table)#> IObjectSet property.</summary>
        IObjectSet<<#=table.Name#>> <#=code.Escape(table)#> { get; }

<#+
		}			
#>
        /// <summary>Persists the changes to the database</summary>
        /// <returns>The number of records affected</returns>
        int Save();

        /// <summary>Executes a stored procedure or function that is defined in the data source and 
        /// expressed in the conceptual model; discards any results returned from the function; and 
        /// returns the number of rows affected by the execution.
        /// </summary>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns> The number of rows affected.</returns>
        int ExecuteFunction(string functionName, params ObjectParameter[] parameters);
               
        /// <summary>Executes a stored procedure or function that is defined in the data source and 
        /// expressed in the conceptual model; discards any results returned from the function; and 
        /// returns the number of rows affected by the execution.
        /// </summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns>An System.Data.Objects.ObjectResult<T> for the data that is returned by the stored procedure.</returns>
        ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, params ObjectParameter[] parameters);

        /// <summary>Executes the given stored procedure or function that is 
        /// defined in the data source and expressed in the conceptual model, 
        /// with the specified parameters, and merge option. Returns a typed 
        /// System.Data.Objects.ObjectResult<T>.</summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="mergeOption">The System.Data.Objects.MergeOption to use when executing the query.</param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns>An System.Data.Objects.ObjectResult<T> for the data that is returned by the stored procedure.</returns>
        ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, MergeOption mergeOption, params ObjectParameter[] parameters);

        /// <summary>Executes an arbitrary command directly against the data source using the existing connection.</summary>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns>The number of rows affected.</returns>
        int ExecuteStoreCommand(string commandText, params object[] parameters);
       
        
        /// <summary>Executes a query directly against the data source that returns a sequence of typed results.</summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns>An enumeration of objects of type TResult.</returns>
        ObjectResult<TElement> ExecuteStoreQuery<TElement>(string commandText, params object[] parameters);

        /// <summary>Executes a query directly against the data source and 
        /// returns a sequence of typed results. Specify the entity set and 
        /// the merge option so that query results can be tracked as 
        /// entities.</summary>
        /// <typeparam name="TEntity">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="entitySetName">The entity set of the TResult type. 
        /// If an entity set name is not provided, the results are not going to be tracked.</param>
        /// <param name="mergeOption">The System.Data.Objects.MergeOption to use when executing the query. The default is System.Data.Objects.MergeOption.AppendOnly.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns></returns>
        ObjectResult<TEntity> ExecuteStoreQuery<TEntity>(string commandText, string entitySetName, MergeOption mergeOption, params object[] parameters);

        /// <summary>IDisposable Dispose method</summary>
        new void Dispose();
    }
}<#+
        return this.GenerationEnvironment.ToString().Replace("\t", "    ");
	}
	
	/// <summary>Validates the template.</summary>
	protected override void Validate()
    {
		if (string.IsNullOrEmpty(this.OutputName))
		{
	        this.Error("OutputName property is empty");
		}

		if (string.IsNullOrEmpty(this.OutputExtension))
		{
	        this.Error("OutputExtension property is empty");
		}
    }	
}
#>
