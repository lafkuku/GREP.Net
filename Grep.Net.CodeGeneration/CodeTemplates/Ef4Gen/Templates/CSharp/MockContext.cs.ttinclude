<#+
// <copyright file="MockContext.cs.ttinclude" company="CompDJ">
//  Copyright © CompDJ. All Rights Reserved.
// </copyright>

/// <summary>T4 Template file.</summary>
public class MockContextCs : T4TemplateBase
{
	EntityContainer container = null;
	
    /// <summary>Initializes a new instance of the MockContextCs class.</summary>
    public MockContextCs() 
    {
		this.container = EntityHelpers.GetMetadataContainer(T4Gen.Parser);
		this.OutputName = "Mock" + code.Escape(container.Name);
		this.OutputExtension = ".cs";
    }
	
	/// <summary>Renders output.</summary>
	public override string TransformText()
	{
		string currentNamespace = this.GetNamespace(T4Config.ContextNamespace, T4Config.Namespace);
		string usings = this.GetUsings(T4Config.ContextNamespace, T4Config.Namespace);
#>
// <copyright file="<#=this.OutputName#><#=T4Config.LanguageFileString()#>" company="<#=T4Config.CompanyName#>">
//  Copyright (c) <#=T4Config.CompanyName#>. All Rights Reserved.
// </copyright>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace <#=currentNamespace#>
{
	using System;
    using System.Data.EntityClient;
    using System.Data.Objects;
<#=usings#>
    /// <summary>Main entity context</summary>
    [System.CodeDom.Compiler.GeneratedCode("<#=T4Config.AppName#>", "<#=T4Config.AppVersion#>")]
    public partial class Mock<#=code.Escape(container)#> : IContext, IDisposable
    {
        /// <summary>Connection String</summary>
		public const string SettingsConnectionString = "name=<#=container.Name#>";
		
		/// <summary>Container name</summary>
		public const string ContainerName = "<#=container.Name#>";

<#+
	foreach (EntityType table in T4Gen.Parser.Metadata.GetItems<EntityType>().OrderBy(c => c.Name))
		{
#>
        /// <summary><#=code.Escape(table)#> backing field.</summary>
		private IObjectSet<<#=code.Escape(table)#>> field<#=code.Escape(table)#>;

<#+
		}
#>
        /// <summary>Initializes a new instance of the <see cref="Mock<#=code.Escape(container)#>"/> class.</summary>
        public Mock<#=code.Escape(container)#>()
        {
        }
    
        /// <summary>Initializes a new instance of the <see cref="Mock<#=code.Escape(container)#>"/> class.</summary>
        /// <param name="connectionString">Database connection string</param>
        public Mock<#=code.Escape(container)#>(string connectionString)
        {
        }
    
        /// <summary>Initializes a new instance of the <see cref="Mock<#=code.Escape(container)#>"/> class.</summary>
        /// <param name="connection">Entity database connection</param>
        public Mock<#=code.Escape(container)#>(System.Data.Common.DbConnection connection)
        {
        }
		
<#+
	foreach (EntityType table in T4Gen.Parser.Metadata.GetItems<EntityType>().OrderBy(c => c.Name))
		{
#>
        /// <summary>Gets the <#=code.Escape(table)#> IObjectSet property.</summary>
        public IObjectSet<<#=table.Name#>> <#=code.Escape(table)#> 
		{
            get { return this.field<#=code.Escape(table)#>  ?? (this.field<#=code.Escape(table)#> = new MockObjectSet<<#=code.Escape(table)#>>()); }
        }
        
<#+
		}			
#>
        /// <summary>Persists the changes to the database</summary>
        /// <returns>The number of records affected</returns>
        public int Save()
        {
            return (int)1;
        }

        /// <summary>IDisposable implementation</summary>
        public void Dispose()
        {           
        }

        /// <summary>Executes a stored procedure or function that is defined in the data source and 
        /// expressed in the conceptual model; discards any results returned from the function; and 
        /// returns the number of rows affected by the execution.
        /// </summary>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns> The number of rows affected.</returns>
        public int ExecuteFunction(string functionName, params ObjectParameter[] parameters)
        {
            return 1;
        }

        /// <summary>Executes a stored procedure or function that is defined in the data source and 
        /// expressed in the conceptual model; discards any results returned from the function; and 
        /// returns the number of rows affected by the execution.
        /// </summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns>An System.Data.Objects.ObjectResult<T> for the data that is returned by the stored procedure.</returns>
        public ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, params ObjectParameter[] parameters)
        {
            return (ObjectResult<TElement>)null;
        }

        /// <summary>Executes the given stored procedure or function that is 
        /// defined in the data source and expressed in the conceptual model, 
        /// with the specified parameters, and merge option. Returns a typed 
        /// System.Data.Objects.ObjectResult<T>.</summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="functionName">The name of the stored procedure or function. The name can include the 
        /// container name, such as Container Name.Function Name. When the default container name is 
        /// known, only the function name is required.
        /// </param>
        /// <param name="mergeOption">The System.Data.Objects.MergeOption to use when executing the query.</param>
        /// <param name="parameters">An array of System.Data.Objects.ObjectParameter objects.</param>
        /// <returns>An System.Data.Objects.ObjectResult<T> for the data that is returned by the stored procedure.</returns>
        public ObjectResult<TElement> ExecuteFunction<TElement>(string functionName, MergeOption mergeOption, params ObjectParameter[] parameters)
        {
            return (ObjectResult<TElement>)null;
        }

        /// <summary>Executes an arbitrary command directly against the data source using the existing connection.</summary>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns>The number of rows affected.</returns>
        public int ExecuteStoreCommand(string commandText, params object[] parameters)
        {
            return 1;
        }

        /// <summary>Executes a query directly against the data source that returns a sequence of typed results.</summary>
        /// <typeparam name="TElement">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns>An enumeration of objects of type TResult.</returns>
        public ObjectResult<TElement> ExecuteStoreQuery<TElement>(string commandText, params object[] parameters)
        {
            return (ObjectResult<TElement>)null;
        }

        /// <summary>Executes a query directly against the data source and 
        /// returns a sequence of typed results. Specify the entity set and 
        /// the merge option so that query results can be tracked as 
        /// entities.</summary>
        /// <typeparam name="TEntity">The entity type of the 
        /// System.Data.Objects.ObjectResult<T> returned when the function is 
        /// executed against the data source. This type must implement 
        /// System.Data.Objects.DataClasses.IEntityWithChangeTracker.</typeparam>
        /// <param name="commandText">The command to execute, in the native language of the data source.</param>
        /// <param name="entitySetName">The entity set of the TResult type. 
        /// If an entity set name is not provided, the results are not going to be tracked.</param>
        /// <param name="mergeOption">The System.Data.Objects.MergeOption to use when executing the query. The default is System.Data.Objects.MergeOption.AppendOnly.</param>
        /// <param name="parameters">An array of parameters to pass to the command.</param>
        /// <returns></returns>
        public ObjectResult<TEntity> ExecuteStoreQuery<TEntity>(string commandText, string entitySetName, MergeOption mergeOption, params object[] parameters)
        {
            return (ObjectResult<TEntity>)null;
        }
    }
}<#+
        return this.GenerationEnvironment.ToString().Replace("\t", "    ");
	}
	
	/// <summary>Validates the template.</summary>
	protected override void Validate()
    {
		if (string.IsNullOrEmpty(this.OutputName))
		{
	        this.Error("OutputName property is empty");
		}

		if (string.IsNullOrEmpty(this.OutputExtension))
		{
	        this.Error("OutputExtension property is empty");
		}
    }	
}
#>
